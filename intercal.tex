% -*- Mode: TeX -*- 
% for LaTeX
\documentstyle[intercal]{article}

\title{                 The INTERCAL Programming Language \\
                                Reference Manual}
\author{                        Donald R. Woods \& James M. Lyon}
\date{                Copyright Donald R. Woods \& James M. Lyon 1973}

% Online version provided by Ken Johnson (ken@aiai.ed.ac.uk)
% Corrected and typeset by Michael Ernst (mernst@theory.lcs.mit.edu), with
% help from the global INTERCAL community.
% Please send corrections to Michael Ernst (mernst@theory.lcs.mit.edu).
% If you don't have TeX, and so can't format this manual, I will send you
% the postscript version.  If you have neither TeX nor Postscript, I'm
% afraid I can't help you.

% sample.i and syslib.i use the continuation character convention
\continuationchartrue
% Convert c,$ => \change and ? => \bookworm
\asciitoebcdictrue


\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\thispagestyle{empty}
\newpage
\setcounter{page}{1}

\section{Introduction}

The names you are about to ignore are true.  However, the story has been
changed significantly.  Any resemblance of the programming language
portrayed here to other programming languages, living or dead, is purely
coincidental.

\subsection{Origin and Purpose}

The INTERCAL programming language was designed the morning of May 26, 1972
by Donald R. Woods and James M. Lyon, at Princeton University.  Exactly
when in the morning will become apparent in the course of this manual.  It
was inspired by one ambition; to have a compiler language which has nothing
at all in common with any other major language.  By ``major'' was meant
anything with which the authors were at all familiar, e.g., FORTRAN, BASIC,
COBOL, ALGOL, SNOBOL, SPITBOL, FOCAL, SOLVE, TEACH, APL, LISP, and PL/I.
For the most part, INTERCAL has remained true to this goal, sharing only
the basic elements such as variables, arrays, and the ability to do I/O,
and eschewing all conventional operations other than the assignment
statement (FORTRAN ``|=|'').

\subsection{Acronym}

The full name of the compiler is ``Compiler Language With No Pronounceable
Acronym,'' which is, for obvious reasons, abbreviated ``INTERCAL.''

\subsection{Acknowledgments}

The authors are deeply indebted to Eric M. Van and Daniel J. Warmenhoven,
without whose unwitting assistance this manual would still have been
possible.








\section{Fundamental Concepts}

In this section an attempt is made to describe how and why INTERCAL may be
used; i.e., what it is like and what it is good for.

\subsection{Sample Program}

Shown below is a relatively simple INTERCAL program which will read in
32-bit unsigned integers, treat them as signed, 2's-complement numbers, and
print out their absolute values.  The program exits if the absolute value
is zero.  Note in particular the inversion routine (statements 6 through
14), which could be greatly simplified if the subroutine library (see
section 5) were used.

A more detailed analysis of a program is made in section 6 of this manual.

\ICverbatimlisting{sample.i}


\subsection{Uses For INTERCAL}

INTERCAL's main advantage over other programming languages is its strict
simplicity.  It has few capabilities, and thus there are few restrictions
to be kept in mind.  Since it is an exceedingly easy language to learn, one
might expect it would be a good language for initiating novice programmers.
Perhaps surprising, than, is the fact that it would be more likely to
initiate a novice into a search for another line of work.  As it turns out,
INTERCAL is more useful (which isn't saying much) as a challenge to
professional programmers.  Those who doubt this need only refer back to the
sample program in section 2.1.  This 22-statement program took somewhere
from 15 to 30 minutes to write, whereas the same objectives can be achieved
by single-statement programs in either SNOBOL;

\begin{verbatim}
        PLEASE INPUT POS(0) ('-' ! '')
        + (SPAN('0123456789') $ OUTPUT)
        + *NE(OUTPUT) :S(PLEASE)F(END)
\end{verbatim}
\noindent or APL;

\IConeline{|[1] >\llap -0=\llap /?<\llap -?|}

Admittedly, neither of these is likely to appear more intelligible to
anyone unfamiliar with the languages involved, but they took roughly 60
seconds and 15 seconds, respectively, to write.  Such is the overwhelming
power of INTERCAL!

The other major importance of INTERCAL lies in its seemingly inexhaustible
capacity for amazing one's fellow programmers, confounding programming shop
managers, winning friends, and influencing people.  It is a well-known and
oft-demonstrated fact that a person whose work is incomprehensible is held
in high esteem.  For example, if one were to state that the simplest way to
store a value of 65536 in a 32-bit INTERCAL variable is:

\begin{verbatim}
        DO :1 <- #0$#256
\end{verbatim}
any sensible programmer would say that that was absurd.  Since this is
indeed the simplest method, the programmer would be made to look foolish in
front of his boss, who would of course happened to turn up, as bosses are
wont to do.  The effect would be no less devastating for the programmer
having been correct.







\section{Description}

The examples of INTERCAL programming which have appeared in the preceding
sections of this manual have probably seemed highly esoteric to the reader
unfamiliar with the language.  With the aim of making them more so, we
present here a description of INTERCAL.


\subsection{Variables}

INTERCAL allows only 2 different types of variables, the 16-bit integer
and the 32-bit integer.  These are represented by a spot (|.|) or two-spot
(|:|), respectively, followed by any number between 1 and 65535, inclusive.
These variables may contain only non-negative numbers; thus they have the
respective ranges of values: 0 to 65535 and 0 to 4294967295.  Note: |.123|
and |:123| are two distinct variables.  On the other hand, |.1| and |.0001|
are identical.  Furthermore, the latter may {\em not} be written as |1E-3|.

\subsection{Constants}

Constants are 16-bit values only and may range from 0 to 65535.  They are
prefixed by a mesh (|#|).  Caution! Under no circumstances confuse the mesh
with the interleave operator, except under confusing circumstances!

\subsection{Arrays}

Arrays are represented by a tail (|,|) for 16-bit values, or a hybrid (|;|)
for 32-bit values, followed by a number between 1 and 65535, inclusive.
The number is suffixed by the word |SUB|, followed by the subscripts,
separated optionally by spaces.  Subscripts may be any expressions,
including those involving subscripted variables.  This occasionally leads
to ambiguous constructions, which are resolved as discussed in section
3.4.3.  Definition of array dimensions will be discussed later in greater
detail, since discussing it in less detail would be difficult.  As before,
|,123| and |;123| are distinct.  In summary, |.123|, |:123|, |#123|,
|,123|, and |:123| are all distinct.

\subsection{Operators}

INTERCAL recognizes 5 operators---2 binary and 3 unary.  Please be kind to
our operators: they may not be very intelligent, but they're all we've got.
In a sense, all 5 operators are binary, as they are all bit-oriented, but
it is not our purpose here to quibble about bits of trivia.



% ******* proofread versus the paper copy only this far !!!! ************




\subsubsection{Binary Operators}

The binary operators are {\sl interleave} (also called {\sl mingle}) and
{\sl select}, which are represented by a change (|$|) and a sqiggle
(|~|), respectively.

The interleave operator takes two 16-bit values and produces a 32-bit
result by alternating the bits of the operands.  Thus, |#65535c#0| has the
32-bit binary form 101010....10 or 2863311530 decimal, while |#0c#65535| =
0101....01 binary = 1431655765 decimal, and |#255c#255| is equivalent to
|#65535|.

The select operator takes from the first operand whichever bits correspond
to 1's in the second operand, and packs these bits to the right in the
result.  Both operands are automatically padded on the left with zeros to
32 bits before the selection takes place, so the variable types are
unrestricted.  If more than 16 bits are selected, the result is a 32-bit
value, otherwise it is a 16-bit value.  For example, |#179~#201| (binary
value 10110011|~|11001001) selects from the first argument the 8th, 7th,
4th, and 1st from last bits, namely, 1001, which = 9.  But |#201~#179|
selects from binary 11001001 the 8th, 6th, 5th, 2nd, and 1st from last
bits, giving 10001 = 17.  |#179~#179| has the value 31, while |#201~#201|
has the value 15.

Perhaps a simpler way of understanding the operation of the select operator
would be to examine the logic diagram on the following page (Figure 1),
which performs the select operation upon two 8-bit values, A and B.  The
gates used are Warmenhovian logic gates, which means the outputs have four
possible values: low, high, undefined (value of an uninitialized
flip-flop), and oscillating (output of a NOR gate with one input low and
the other input connected to the output).  These values are represented
symbolically by '|0|', '|1|', '{\tt ?}', and '|F|'.  Note in particular that,
while NOT-|0| is |1| and NOT-|1| is |0| as in two-valued logic, NOT-{\tt ?} is
{\tt ?} and NOT-|F| is |F|.  The functions of the various gates are listed in
Table 1.
\stepcounter{table}








\subsubsection{Unary Operators}

The unary operators are |&| (logical AND), |V| (logical OR), and
|\bookworm| (logical XOR).  This last character is obtained by overpunching
a worm (|-|) on a V (|V|).  The operator is inserted between the spot,
two-spot, mesh, or what-have-you, and the integer, thus: |.&123|, |#V123|.
Multiple unary operators may not be concatenated, thus the form |#V&123| is
invalid.  This will be covered later when precedence is discussed. These
operators perform their respective logical operations on all pairs of
adjacent bits, the result from the first and last bits going into the first
(most significant) bit of the result.  The effect is that of rotating the
operand one place to the right and ANDing, ORing, or XORing with its
initial value.  Thus, |#&77| (|#77| = binary 1001101) is binary 0000000000000100
= 4, |#V77| is binary 1000000001101111 = 32879, and |#?77| is binary
1000000001101011 = 32875.

\subsubsection{Precedence}

Precedence of operators is as follows:\footnote{Keep in mind that the aim in designing INTERCAL was to have no
precedents.}
\stepcounter{footnote}


% \vspace{2 in}
% \hspace{4 in}
% \footnote{Keep in mind that the aim in designing INTERCAL was to have no
% precedents.}
% \stepcounter{footnote}
% \vspace{1 in}
% (The remainder of this page intentionally left blank.)

\vfill
(The remainder of this page intentionally left blank.)
\newpage


















%% This manual only strictly checked up to (but not including) the 34815.

This precedence (or lack thereof) may be overruled by grouping expressions
between pairs of sparks (|'|) or rabbit-ears (|"|).  Thus
|'#165c#203'~#358| (binary value |'|10100101|c|11001011|'~|101100110) has
the value 15, but |#165c'#203~#358'| has the value 34815, and
|#165c#203~#358| is invalid syntax and is completely valueless (except
perhaps as an educational tool to the programmer).  A unary operator is
applied to a sparked or rabbit-eared expression by inserting the operator
immediately following the opening spark or ears.  Thus, the invalid
expression |#V&123|, which was described earlier, could be coded as
|'V#&123'| or |'V"&#123"'|.  Note: In the interests of simplifying the
sometimes overly-complex form of expressions, INTERCAL allows a spark-spot
combination (|'.|) to be replaced with a wow (|!|).  Thus |'.1~.2'| is
equivalent to |!1~.2'|, and |'V.1c.2'| is equivalent to |"V!1c.2'"|.
%\typeout{Note that unary ops must go INSIDE delimiters!}

Combining a rabbit-ears with a spot to form a rabbit (|\rabbit|)
is not permitted, although the programmer is free to use it should he find
an EBCDIC reader which will properly translate a 12-3-7-8 punch.

Sparks and/or rabbit-ears must also be used to distinguish among such
otherwise ambiguous subscripted and multiply-subscripted expressions as:

\begin{verbatim} 
        ,1 SUB #1 ~ #2
        ,1 SUB ,2 SUB #1 #2 #3
        ,1 SUB " ,2 SUB " ,3 SUB #1 " #2 " " #3 "
\end{verbatim}

The third case may be isolated into either of its possible interpretations
by simply changing some pairs of rabbit-ears to sparks, instead of adding
more ears (which would only confuse the issue further).  Ambiguous cases
are defined as those for which the compiler being used finds a legitimate
interpretation which is different from that which the user had in mind.
See also section 8.1.






\section{Statements}

In this section is described the format of INTERCAL statements.

\subsection{General Format}

Statements may be entered in ``free format.''  That is, more than one
statement may occur on a single card, and a statement may begin on one card
and end on a later one.  Note that if this is done, all intervening cards
and portions thereof must be part of the same statement.  That this
restriction is necessary is immediately apparent from the following example
of what might occur if statements could be interlaced.

\begin{verbatim} 
        DO .1 <- ".1c'&:51~"#V1c!12~;&75SUB"V'V.1~
        DO .2 <- '"!1c"&';V79SUB",&7SUB:173"'~!V9c
        .2'c,&1SUB:5~#33578"'"'"~'#65535c"V'V#&85'"'
        #8196'"'~.1"c.2'~'#&5c"'#1279c#4351'~#65535"'
\end{verbatim} 
The above statements are obviously meaningless.  (For that matter, so are
the statements

\begin{verbatim}
        DO .1 <- ".1c"&:51~"#V1c!12~;&75SUB"V'V.1~
        .2'C,&1SUB:5~/333578"'"'"~#65535c"V'V#&85'"'
        DO .2 <- '"!1c"&';V79SUB",&7SUB:173"'~!V9c
        #8196'"'~.1"c.2'~'#&5c"'#1279c!4351'~#65535"'
\end{verbatim}
but this is not of interest here.)

Spaces may be used freely to enhance program legibility (or at least reduce
program illegibility), with the restriction that no word of a statement
identifier (see section 4.3) may contain any spaces.

\subsection{Labels}

A statement may begin with a {\sl logical line label} enclosed in wax-wane pairs
(|()|).  A statement may not have more than one label, although it is
possible to omit the label entirely.  A line label is any integer from 1 to
65535, which must be unique within each program.  The user is cautioned,
however, that many line labels between 1000 and 1999 are used in the
INTERCAL System Library functions.

\subsection{Identifiers and Qualifiers}

After the line label (if any), must follow one of the following statement
identifiers: |DO|, |PLEASE|, or |PLEASE DO|.  These may be used
interchangeably to improve the aesthetics of the program.  The identifier
is then followed by either, neither, or both of the following optional
parameters (qualifiers):
\begin{enumerate}
\item either of the character strings |NOT| or |N'T|, which causes the statement
to be automatically abstained from (see section 4.4.9) when execution
begins, and
\item a number between 0 and 100, preceded by a double-oh-seven
(|%|), which causes the statement to have only the specified percent chance
of being executed each time it is encountered in the course of execution.
\end{enumerate}







\subsection{Statements} 

Following the qualifiers (or, if none are used, the identifier) must occur
one of the 13 valid operations.  (Exception: see section 4.5.) These are
described individually in sections 4.4.1 through 4.4.13.

\subsubsection{Calculate}

The INTERCAL equivalent of the half-mesh (|=|) in FORTRAN, BASIC, PL/I, and
others, is represented by an angle (|<|) followed by a worm (|-|).  This
combination is read ``gets.''  32-bit variables may be assigned 16-bit
values, which are padded on the left with 16 zero bits.  16-bit variables
may be assigned 32-bit values only if the value is less than 65535.  Thus,
to invert the least significant bit of the first element of 16-bit
2-dimensional array number 1, one could write:

\begin{verbatim}
        ,1SUB#1#1 <- 'V,1SUB#1#1c#1'~'#0c#65535'
\end{verbatim}

Similarly to SNOBOL and SPITBOL, INTERCAL uses the angle-worm to define the
dimensions of arrays.  An example will probably best describe the format.
To define 32-bit array number 7 as 3-dimensional, the first dimension being
seven, the second being the current value of 16-bit variable number seven,
and the third being the current value of the seventh element of 16-bit
array number seven (which is one-dimensional) mingled with the last three
bits of 32-bit variable number seven, one would write (just before they
came to take him away):

\begin{verbatim}
        ;7 <- #7 BY .7 BY ",7SUB#7"c':7~#7'
\end{verbatim}
This is, of course, different from the statement:

\begin{verbatim}
        ;7 <- #7 BY .7 BY ,7SUB"#7c':7~#7'"
\end{verbatim}

INTERCAL also permits the redefining of array dimensioning, which is done
the same way as is the initial dimensioning.  All values of items in an
array are lost upon redimensioning, unless they have been |STASH|ed (see
section 4.4.5), in which case restoring them also restores the old
dimensions.







\subsubsection{Next}

The |NEXT| statement is used both for subroutine calls and for
unconditional transfers.  This statement takes the form:

\IConeline{|DO ({\em label}) NEXT|}

\noindent
(or, of course,
\IConeline{|PLEASE DO ({\em label}) NEXT|}

\noindent
etc.), where |({\em label})| represents any logical line label which
appears in the program.  The effect of such a statement is to transfer
control to the statement specified, and to store in a push down list (which
is initially empty) the location from which the transfer takes place.
Items may be removed from this list and may be discarded or used to return
to the statement immediately following the |NEXT| statement.  These
operations are described in sections 4.4.3 and 4.4.4 respectively.  The
programmer is generally advised to discard any stack entries which he does
not intend to utilize, since the stack has a maximum depth of 79 entries.
A program's attempting to initiate an 80th level of |NEXT|ing will result
on the fatal error message, ``PROGRAM HAS DISAPPEARED INTO THE BLACK
LAGOON.''

\subsubsection{Forget}

The statement |PLEASE FORGET| {\em exp}, where {\em exp} represents any
expression (except colloquial and facial expressions), causes the
expression to be evaluated, and the specified number of entries to be
removed from the |NEXT|ing stack and discarded.  An attempt to |FORGET|
more levels of |NEXT|ing than are currently stacked will cause the stack to
be emptied, and no error condition is indicated.  This is because the
condition is not considered to be an error.  As described in section 4.4.2,
it is good programming practice to execute a |DO FORGET #1| after using a
|NEXT| statement as an unconditional transfer, so that the stack does not
get cluttered up with unused entries:

\begin{verbatim}
        DO (123) NEXT
        .
        .
  (123) DO FORGET #1
\end{verbatim}

\subsubsection{Resume}

The statement |PLEASE RESUME| {\em exp} has the same effect as |FORGET|,
except that program control is returned to the statement immediately
following the |NEXT| statement which stored in the stack the last entry to
be removed.  Note that a rough equivalent of the FORTRAN computed |GO TO|
and BASIC |ON| {\em exp} |GO TO| is performed by a sequence of the form:

\begin{verbatim}
        DO (1) NEXT
        .
        .
    (1) DO (2) NEXT
        PLEASE FORGET #1
        .
        .
    (2) DO RESUME .1
\end{verbatim}

Unlike the |FORGET| statement, an attempt to |RESUME| more levels of
|NEXT|ing than been stacked will cause program termination.  See also
section 4.4.11.


\subsubsection{Stash}

Since subroutines are not explicitly implemented in INTERCAL, the |NEXT|
and |RESUME| statements must be used to execute common routines.  However,
as these routines might use the same variables as the main program, it is
necessary for them to save the values of any variables whose values they
alter, and later restore them.  This process is simplified by the |STASH|
state ment, which has the form |DO STASH| {\em list}, where {\em list}
represents a string of one or more variable or array names, separated by
intersections (|+|).  Thus

\begin{verbatim}
        PLEASE STASH .123+:123+,123
\end{verbatim}
stashes the values of two variables and one entire array.  The values are
left intact, and copies thereof are saved for later retrieval by (what
else?)  the |RETRIEVE| statement (see section 4.4.6).  It is not possible
to |STASH| single array items.

\subsubsection{Retrieve}

|PLEASE RETRIEVE| {\em list} restores the previously |STASH|ed values of
the variables and arrays named in the list.  If a value has been
stashed more than once, the most recently |STASH|ed values are |RETRIEVE|d,
and a second |RETRIEVE| will restore the second most recent values
|STASH|ed.  Attempting to |RETRIEVE| a value which has not been |STASH|ed
will result in the error message, ``THROW STICK BEFORE RETRIEVING.''

\subsubsection{Ignore}

The statement |DO IGNORE| {\em list} causes all subsequent statements to
have no effect upon variables and/or arrays named in the list.  Thus, for
example, after the sequence

\begin{verbatim}
        DO .1 <- #1
        PLEASE IGNORE .1
        DO .1 <- #0
\end{verbatim}
16-bit variable number 1 would have the value 1, not 0.  Inputting (see
section 4.4.12) into an |IGNORE|d variable also has no effect.  The
condition is annulled via the |REMEMBER| statement (see section 4.4.8).
Note that, when a variable is being |IGNORE|d, its value, though immutable,
is still available for use in expressions and the like.

\subsubsection{Remember}

|PLEASE REMEMBER| {\em list} terminates the effect of the |IGNORE|
statement for all variables and/or arrays named in the list.  It does not
matter if a variable has been |IGNORE|d more than once, nor is it an error
if the variable has not been |IGNORE|d at all.

\subsubsection{Abstain}

INTERCAL contains no simple equivalent to an |IF| statement or computed |GO
TO|, making it difficult to combine similar sections of code into a single
routine which occasionally skips around certain statements.  The |IGNORE|
statement (see section 4.4.7) is helpful in some cases, but a more viable
method is often required.  In keeping with the goal of INTERCAL having
nothing in common with any other language, this is made possible via the
|ABSTAIN| statement.

This statement takes on one of two forms.  It may not take on both at any
one time.  |DO ABSTAIN FROM ({\em label})| causes the statement whose
logical line label is |({\em label})| to be abstained form.  |PLEASE
ABSTAIN FROM| {\em gerund list} causes all statements of the specified
type(s) to be abstained from, as in

\begin{verbatim}
        PLEASE ABSTAIN FROM STASHING
        PLEASE ABSTAIN FROM IGNORING + FORGETTING
        PLEASE ABSTAIN FROM NEXTING
        PLEASE ABSTAIN FROM CALCULATING
\end{verbatim}


Statements may also be automatically abstained from at the start of
execution via the |NOT| or |N'T| parameter (see section 4.3).


If, in the course of execution, a statement is encountered which is being
abstained from, it is ignored and control passes to the next statement in
the program (unless it, too, is being abstained from).

The statement |DO ABSTAIN FROM ABSTAINING| is perfectly valid, as is |DO
ABSTAIN FROM REINSTATING| (although this latter is not usually
recommended).  However, the statement |DO ABSTAIN FROM GIVING UP| is not
accepted, even though |DON'T GIVE UP| is.

\subsubsection{Reinstate}
\newlength{\QEDlen}\settowidth{\QEDlen}{Q.E.D.}\newlength{\lastlinelen}
\settowidth{\lastlinelen}{Since $x+y$ cannot equal anything but 0, $x+y=0$.}
\addtolength{\lastlinelen}{-1\QEDlen}

The |REINSTATE| statement, like the |ABSTAIN|, takes as an argument either
a line label or a gerund list.  No other form of argument is permitted.
For example, the following is an invalid argument:
\begin{quote}
        Given: $x\neq0$, $y\neq0$,  Prove: $x+y=0$. \\
        Since $x\neq0$, then $x+1\neq1$, $x+a\neq a$, $x+y\neq y$. \\
        Thus $x+y \neq$ anything but 0. \\
        Since $x+y$ cannot equal anything but 0, $x+y=0$. \\
	\hspace*{\lastlinelen} Q.E.D.
\end{quote}

|REINSTATE|ment nullifies the effects of an abstention.  Either form of
|REINSTATE|ment can be used to ``free'' a statement, regardless of whether
the statement was abstained from by gerund list, line label, or |NOT|.
Thus, |PLEASE REINSTATE REINSTATING| is not necessarily an irrelevant
statement, since it might free a |DON'T REINSTATE| command or a |REINSTATE|
the line label of which was abstained from.  However, |DO REINSTATE GIVING
UP| is invalid, and attempting to |REINSTATE| a |GIVE UP| statement by line
label will have no effect.  Note that this insures that |DON'T GIVE UP|
will always be a ``do-nothing'' statement.

\subsubsection{Give Up}

|PLEASE GIVE UP| is used to exit from a program.  It has the effect of a
|PLEASE RESUME #80|.  |DON'T GIVE UP|, as noted in section 4.4.10, is
effectively a null statement.

\subsubsection{Input}

Input is accomplished with the statement |DO WRITE IN| {\em list}, where
{\em list} represents a string of variables and/or elements or arrays,
separated by intersections.  Numbers are represented on cards, each number
on a separate card, by spelling out each digit (in English) and separating
the digits with one or more spaces.  A zero (0) may be spelled as either
|ZERO| or |OH|.  Thus the range of (32-bit) input values permissible
extends from |ZERO| (or |OH|) through |FOUR TWO NINE FOUR NINE SIX SEVEN
TWO NINE FIVE|.

Attempting to write in a value greater than or equal to |SIX FIVE FIVE
THREE SIX| for a 16-bit variable will result in the error message, ``DON'T
BYTE OFF MORE THAN YOU CAN CHEW.''

\subsubsection{Output}

Values may be output to the printer, one value per line, via the statement
|DO READ OUT| {\em list}, where the list contains variables, array
elements, and/or constants.  Output is in the form of ``extended'' Roman
numerals (also called ``butchered'' Roman numerals), with an overline
(\zero) indicating the value below is ``times 1000,'' and lower-case
letters indicating ``times 1000000.''  Zero is indicated by an overline
with no character underneath.  Thus, the range of (32-bit) output values
possible is from \zero\ through \=i\=vccxciv\=C\=M\=L\=X\=V\=I\=ICCXCV.
Note: For values whose residues modulo 1000000 are less than 4000, M is
used to represent 1000; for values whose residues are 4000 or greater, \=I
is used.  Thus |#3999| would read out as MMMIM while |#4000| would read out
as \=I\=V.  Similar rules apply to the use of \=M and i for 1000000, and to
that of \=m and \=i for 1000000000.

% \typeout{Do they mean MMMIM and not MMMCMXCIX??}







\subsection{Comments}

Unrecognizable statements, as noted in section 7, are flagged with a splat
(|*|) during compilation, and are not considered fatal errors unless they
are encountered during execution, at which time the statement (as input at
compilation time) is printed and execution is terminated.  This allows for
an interesting (and, by necessity, unique) means of including comments in
an INTERCAL listing.  For example, the statement:

\begin{verbatim}
*       PLEASE NOTE THAT THIS LINE HAS NO EFFECT
\end{verbatim}
will be ignored during execution due to the inclusion of the NOT qualifier.
User-supplied error messages are also easy to implement:

\begin{verbatim}
*       DO SOMETHING ABOUT OVERFLOW IN ;3
\end{verbatim}
as are certain simple conditional errors:

\begin{verbatim}
* (123) DON'T YOU REALIZE THIS STATEMENT SHOULD ONLY BE ENCOUNTERED
                ONCE?
        PLEASE REINSTATE (123)
\end{verbatim}
This pair of statements will cause an error exit the second time they are
encountered.  Caution!!  The appearance of a statement identifier in an
intended comment will be taken as the beginning of a new statement.  Thus,
the first example on the preceding page could not have been:

\begin{verbatim}
*       PLEASE NOTE THAT THIS LINE DOES NOTHING
\end{verbatim}
The third example, however, is valid, despite the appearance of two cases
of |D|-space-|O|, since INTERCAL does not ignore extraneous spaces in
statement identifiers.






\section{Subroutine Library}

INTERCAL provides several built-in subroutines to which control can be
transferred to perform various operations.  These operations include many
useful functions which are not easily representable in INTERCAL, such as
addition, subtraction, etc.

\subsection{Usage}

In general, the operands are |.1|, |.2|, etc., or |:1|, |:2|, etc., and the
result(s) are stored in what would have been the next operand(s).  For
instance, one routine adds |.1| to |.2| and store the sum in |.3|, with
|.4| being used to indicate overflow.  All variables not used for results
are left unchanged.

\subsection{Available Functions}

At the time of this writing, only the most fundamental operations are
offered in the library, as a more complete selection would require
prohibitive time and coree to implement.  These functions, along with their
corresponding entry points (entered via |DO ({\em entry}) NEXT|) are listed
below.

\begin{verbatim}
 (1000) .3 <- .1 plus .2, error exit on overflow
 (1009) .3 <- .1 plus .2
        .4 <- #1 if no overflow, else .4 <- #2
 (1010) .3 <- .1 minus .2, no action on overflow
 (1020) .1 <- .1 plus #1, no action on overflow
 (1030) .3 <- .1 times .2, error exit on overflow
 (1039) .3 <- .1 times .2
        .4 <- #1 if no overflow, else .4 <- #2
 (1040) .3 <- .1 divided by .2
        .3 <- #0 if .2 is #0
 (1050) .2 <- :1 divided by .1, error exit on overflow
        .2 <- #0 if .1 is #0

 (1500) :3 <- :1 plus :2, error exit on overflow
 (1509) :3 <- :1 plus :2
        :4 <- #1 if no overflow, else :4 <- #2
 (1510) :3 <- :1 minus :2, no action on overflow
 (1520) :1 <- .1 concatenated with .2
 (1525) This subroutine is intended solely for internal
        use within the subroutine library and is therefore
        not described here.  Its effect is to shift .3
        logically 8 bits to the left.
 (1530) :1 <- .1 times .2
 (1540) :3 <- :1 times :2, error exit on overflow
 (1549) :3 <- :1 times :2
        :4 <- #1 if no overflow, else :4 <- #2
 (1550) :3 <- :1 divided by :2
        :3 <- #0 if :2 is #0

 (1900) .1 <- uniform random no. from #1 to #65535
 (1910) .2 <- normal random no. from #0 to .1, with
              standard deviation .1 divided by #12
\end{verbatim}







\section{Programming Hints}

For the user looking to become more familiar with the INTERCAL language, we
present in this section an analysis of a complex program, as well as some
suggested projects for the ambitious programmer.

Considering the effort involved in writing an INTERCAL program, it was 
decided in putting together this manual to use an already existing program 
for instructive analysis.  Since there was only one such program available,
we have proceeded to use it.  It is known as the ``INTERCAL System Library.''

\subsection{Description}

The program listing begins on the second page following.  It is in the same
format as would be produced by the Princeton INTERCAL compiler in FORMAT
mode with WIDTH=62 (see section 8).  For a description of the functions
performed by the Library, see section 5.2.

\subsection{Analysis}

We shall not attempt to discuss here the algorithms used, but rather we
shall point out some of the general techniques applicable to a wide range
of problems.

Statements 10, 14, 15, and 26 make up a virtual ``computed |GO TO|.''  When
statement 10 is executed, control passes eventually to statement 16 or 11,
depending on whether |.5| contains |#1| or |#2|, respectively.  The value
of |.5| is determined in statement 9, which demonstrates another handy
technique.  To turn an expression, {\em exp}, with value |#0| or |#1|, into
|#1| or |#2| (for use in a ``|GO TO|''), use |"?'{\em exp}'c#1"~#3|.  To
reverse the condition (i.e., convert |#0| to |#2| and leave |#1| alone) use
|"?'{\em exp}'c#2"~#3|.

Certain conditions are easily checked.  For example, to test for zero,
select the value from itself and select the bottom bit (see statement 54).
To test for all bits being 1's, select the value from itself and select the
top bit (see statement 261).  The test for greater than, performed in
statements 192 and 193 on 32-bit values, employs binary logical operations,
which are performed as follows:

\begin{verbatim}
        'V.1c.2'~'#0c#65535'
\end{verbatim}
for 16-bit values or, for 32-bit values:

\begin{verbatim}
        "'V":1~'#65535c30'"c":2~'#65535c#0'"'~'#0
        c#65535'"c"'V":1~'#0c#65535'"c":2~'#0
        c#65535'"'~'#0c#65535'"
\end{verbatim}
(The proofs are left as an exercise to the reader.)

Testing for greater-than with 16-bit values is somewhat simpler and is done
with the pair of statements:

\begin{verbatim}
        DO .C <- 'V.Ac.B'~'#0c#65535'
        DO .C <- '&"'.A~.C'~'"V'V.C~.C'c#32768"
                ~"#0c#65535"'"c".C~.CZ''ZZZ`#1
\end{verbatim}
This sets |.C| (a dummy variable) to |#1| if |.A| $>$ |.B|, and |#0|
otherwise.  The expression may be expanded as described above to instead
set |.C| to |#1| or |#2|.

Note also in statement 220 the occurrence of |~"#65535c65535"|.  Although
these operations select the entire value, they are not extraneous, as they
ensure that the forthcoming |V|s will be operating on 32-bit values.

In several virtual computed |GO TO|s the |DO FORGET #1| (statement 15 in the
earlier example) has been omitted, since the next transfer of control would
be a |DO RESUME #1|.  By making this a |DO RESUME #2| instead, the |FORGET| may
be forgotten.

In statement 64, note that .2 is |STASH|ed twice by a single statement.  This
is perfectly legal.

Lastly, note in statements 243 and 214 respectively, expressions for
shifting 16- and 32-bit variables logically one place to the left.
Statement 231 demonstrates right-shifting for 32-bit variables.

% MIKE GETS TO INSERT THE PROGRAM HERE!

\subsection{Program Listing}

% Thanks to David Moews (moews@math.berkeley.edu) for help debugging this.
% There is still much to be done!
\ICverbatimlisting{syslib.i}
%\typeout{Where's line 1551?  1900?  1910?}






\subsection{Programming Suggestions}

For the novice INTERCAL programmer, we provide here a list of suggested 
INTERCAL programming projects:

Write an integer exponentiation subroutine.  |:1 <- .1| raised to the |.2| power.

Write a double-precision sorting subroutine.  Given 32-bit array |;1| of
size |:1|, sort the contents into numerically increasing order, leaving the
results in |;1|.

Generate a table of prime numbers.

Put together a floating-point library, using 32-bit variables to represent
floating-point numbers (let the upper half be the mantissa and the lower
half be the characteristic).   The library should be capable of performing 
floating-point addition, subtraction, multiplication, and division, as well
as the natural logarithm function.

Program a Fast Fourier Transform (FFT).   This project would probably entail
the writing of the floating-point library as well as sine and cosine functions.

Calculate, to |:1| places, the value of pi.







\section{Error Messages}

Due to INTERCAL's implementation of comment lines (see section 4.5), most
error messages are produced during execution instead of during compilation.
All errors except those not causing immediate termination of program execution
are treated as fatal.

\subsection{Format}

All error messages appear in the following form:

\begin{verbatim}
        ICLnnnI (error message)
                ON THE WAY TO STATEMENT nnnn
                CORRECT SOURCE AND RESUBMIT
\end{verbatim}

The message varies depending upon the error involved.  For undecodable
statements the message is the statement itself.  The second line tells
which statement would have been executed next had the error not occurred.
Note that if the error is due to 80 attempted levels of |NEXT|ing, the
statement which would have been executed next need not be anywhere near the
statement causing the error.

\subsection{Messages}

Brief descriptions of the different error types are listed below according
to message number.

\begin{description}
\def\ttitem#1{\item[{\tt #1}]}

\ttitem{000} An undecodable statement has been encountered in the course of
        execution.  Note that keypunching errors can be slightly disastrous,
        since if `|FORGET|' were misspelled F-O-R-G-E-R, the results would 
        probably not be those desired.  Extreme misspellings may have even 
        more surprising consequences.  For example, misspelling `|FORGET|' 
        R-E-S-U-M-E could have drastic results.

\ttitem{017} An expression contains a syntax error.

\ttitem{079} Improper use has been made of statement identifiers.

\ttitem{099} Improper use has been made of statement identifiers.

\ttitem{123} Program has attempted 80 levels of |NEXT|ing.

\ttitem{129} Program has attempted to transfer to a non-existent line label.

\ttitem{139} An |ABSTAIN| or |REINSTATE| statement references a non-existent line label.

\ttitem{182} A line label has been multiply defined.

\ttitem{197} An invalid line label has been encountered.

\ttitem{200} An expression involves an unidentified variable.

\ttitem{240} An attempt has been made to give an array a dimension of zero.

\ttitem{241} Invalid dimensioning information was supplied in defining or using
        an array.

\ttitem{275} A 32-bit value has been assigned to a 16-bit variable.

\ttitem{436} A retrieval has been attempted for an un|STASH|ed value.

\ttitem{533} A |WRITE IN| statement or interleave (|$|) operation has
produced a value requiring over 32 bits to represent.

\ttitem{562} Insufficient data.

\ttitem{579} Input data is invalid.

\ttitem{621} The expression of a |RESUME| statement evaluated to |#0|.

\ttitem{632} Program execution was terminated via a |RESUME| statement instead of
        |GIVE UP|.

\ttitem{633} Execution has passed beyond the last statement of the program.

\ttitem{774} A compiler error has occurred (see section 8.1).

\ttitem{778} An unexplainable compiler error has occurred (see J. Lyon or B. Woods).
\end{description}




\section*{Tonsil\footnote{Since all other reference manuals
have Appendices, it was decided that the INTERCAL manual should contain
some other type of removable organ.} A:  The Official INTERCAL Character Set}
\addtonsilline{A}{The Official INTERCAL Character Set}
%\addcontentsline{toc}{section}{\protect\numberline{A}The Official INTERCAL Character Set}

Tabulated on page~\pageref{Tonsil-A-table} are all the characters used in
INTERCAL, excepting letters and digits, along with their names and
interpretations.  Also included are several characters not used in
INTERCAL, which are presented for completeness and to allow for future
expansion.
\stepcounter{footnote}
\footnotetext{This footnote intentionally unreferenced.}

{\catcode`.=\active \catcode`|=12  % Use . instead of | for code mode
\def.{\bgroup\tt\usespecials\def.{\null\egroup}}
\begin{table}
\label{Tonsil-A-table}
\begin{minipage}{\textwidth} % use a minipage so the footnote works
\begin{tabular}{|r|l|p{3in}|}
\hline
Character &	Name &			Use (if any) \\
\hline
.\spot.	&	spot &			identify 16-bit variable      \\
.:.	&	two-spot &		identify 32-bit variable      \\
.,.	&	tail &			identify 16-bit array	      \\
.;.	&	hybrid &		identify 32-bit array	      \\
.\#.	&	mesh &			identify constant	      \\
.=.	&	half-mesh &					      \\
.'.	&	spark &			grouper			      \\
.`.	&	backspark &					      \\
.!.	&	wow &			equivalent to spark-spot      \\
\verb|?|&	what &			unary exlusive OR (ASCII)     \\
.".	&	rabbit-ears &		grouper			      \\
.\rabbit.&	rabbit &		equivalent to ears-spot	      \\
{\verb+|+}&	spike &						      \\
.\%.	&	double-oh-seven &	percentage qualifier	      \\
.-.	&	worm &			used with angles	      \\
.<.	&	angle &			used with worms		      \\
.>.	&	right angle &					      \\
.(.	&	wax &			precedes line label	      \\
.).	&	wane &			follows line label	      \\
.[.	&	U turn &					      \\
.].	&	U turn back &					      \\
.\{.	&	embrace &					      \\
.\}.	&	bracelet &					      \\
.*.	&	splat &			flags invalid statements      \\
.\&.	&	ampersand\footnotemark & unary logical AND 	      \\
.V.	&	V (or book) &		unary logical OR	      \\
.\bookworm. &	bookworm (or universal qualifier) & unary exclusive OR      \\
.\$.	&	big money &		binary mingle (ASCII)	      \\
.\Change.&	change &		binary mingle		      \\
.\~{}.	&	sqiggle &		binary select		      \\
.\_.	&	flat worm &					      \\
.\zero.	&	overline &		indicates ``times 1000''      \\
.+.	&	intersection &		separates list items	      \\
./.	&	slat &							\\
{\verb|\|}&	backslat &						\\
.@.	&	whirlpool &					      \\
.\hookworm.& hookworm &					       \\
{\verb|^|}&	shark (or simply sharkfin) &			      \\
.\blotCh.&	blotch						      \\
\hline
\end{tabular}
\catcode`.=12
\caption{		  INTERCAL character set (top view).}
\def\thempfootnote{\arabic{mpfootnote}}
\footnotetext[\thefootnote]{Got any better ideas?}
\label{character-set}
\end{minipage}
\end{table}
}


\tonsil{B}{Notes On The Atari Implementation}
% \section*{Tonsil B: 
% Notes On The Atari Implementation}
% \addtonsilline{B}{Notes On The Atari Implementation}
%\addcontentsline{toc}{section}{\protect\numberline{B}{Notes On The Atari Implementation}}

The Atari implementation of INTERCAL differs from the original Princeton
version primarily in the use of ASCII rather than EBCDIC.  Since there is
no ``change'' sign ({\tt\change}) in ASCII, we have substituted the ``big
money'' ({\tt\bigmoney}) as the mingle operator.  We feel that this
correctly represents the increasing cost of software in relation to
hardware.  (Consider that in 1970 one could get RUNOFF for free, to run on
a \$20K machine, whereas today a not quite as powerful formatter costs \$99
and runs on a \$75 machine.)  We also feel that there should be no
defensible contention that INTERCAL has any sense.  Also, since overpunches
are difficult to read on the average VDT, the exclusive-or operator may be
written {\tt ?}.  This correctly expresses the average person's reaction on
first encountering exclusive-or, especially on a PDP-11.  Note that in both
of these cases, the over-punched symbol may also be used if one is
masochistic, or concerned with portability to the Princeton compiler.  The
correct over-punch for ``change'' is ``c{\sc
$\langle$backspace$\rangle$}/'' and the correct over-punch for |\bookworm|
is "V{\sc $\langle$backspace$\rangle$}-".  These codes will be properly
printed if you have a proper printer, and the corresponding EBCDIC code
will be produced by the |/IBM| option on the |LIST| command.

\end{document}
