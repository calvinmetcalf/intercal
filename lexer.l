%{
#include <stdio.h>
#include <ctype.h>
#include "ick.h"
#include "y.tab.h"

#ifdef MAIN
YYSTYPE	yylval;
#endif /* MAIN */

char *textlines[MAXLINES];

static char linebuf[YYLMAX];
static char *lineptr = linebuf;

/*
 * The spectacular ugliness of INTERCAL syntax requires that the lexical
 * analyzer have two levels. One, embedded in the getc() function, handles
 * logical-line continuation and the ! abbrev, and stashes each logical
 * line away in a buffer accessible to the code generator (this is necessary
 * for the * construct to be interpreted correctly). The upper level is
 * generated by lex(1) and does normal tokenizing.
 */

#undef getc
int getc(fp)
FILE	*fp;
{
    bool bangflag = FALSE;

    if (bangflag)
    {
	bangflag = FALSE;
	*lineptr++ = '!';
	return('.');
    }
    else
    {
	int c = fgetc(fp);

	if (feof(yyin))
	{
	    *lineptr = '\0';
	    return(EOF);
	}
	else if (c == '\\')
	{
	    do {
		c = fgetc(fp);
	    } while
		(c != '\\' && isspace(c));
	}

	if (c == '!')
	{
	    *lineptr++ = '!';
	    bangflag = TRUE;
	    return(c = '\'');
	}
	else if (c == '\n')
	{
	    extern char *strdup();

	    *lineptr = '\0';
	    lineptr = linebuf;
	    textlines[yylineno] = strdup(linebuf);
	    return('\n');
	}
	else
	{
	    if (islower(c))
		c = toupper(c);
	    return(*lineptr++ = c);
	}
    }
}

%}

W	[\ \t\n]*
D	[0-9][0-9]*

%%

[0-9][0-9]*	{yylval.numval = atoi(yytext); return(NUMBER);}
\.		{return(ONESPOT);}
\:		{return(TWOSPOT);}
\,		{return(TAIL);}
\;		{return(HYBRID);}
\#		{return(MESH);}

\$		{return(MINGLE);}
\~		{return(SELECT);}

\&		{yylval.numval = AND; return(UNARY);}
V		{yylval.numval = OR; return(UNARY);}
\?		{yylval.numval = XOR; return(UNARY);}

\'		{return(SPARK);}
\"		{return(EARS);}

\({D}\)		{yylval.numval = atoi(yytext + 1); return(LABEL);}

DO		{return(DO);}
PLEASE		{return(DO);}
PLEASE{W}DO	{return(DO);}
NOT		{return(NOT);}
DON\'T		{return(NOT);}

\%{D}		{yylval.numval = atoi(yytext + 1); return(OHOHSEVEN);}
SUB		{return(SUB);}
BY		{return(BY);}

\<-		{return(GETS);}
CALCULATING	{yylval.numval = GETS; return(GERUND);}

NEXT		{return(NEXT);}
NEXTING		{yylval.numval = NEXT; return(GERUND);}
FORGET		{return(FORGET);}
FORGETTING	{yylval.numval = FORGET; return(GERUND);}
RESUME		{return(RESUME);}
RESUMING	{yylval.numval = RESUME; return(GERUND);}
STASH		{return(STASH);}
STASHING	{yylval.numval = STASH; return(GERUND);}
RETRIEVE	{return(RETRIEVE);}
RETRIEVING	{yylval.numval = RETRIEVE; return(GERUND);}
IGNORE		{return(IGNORE);}
IGNORING	{yylval.numval = IGNORE; return(GERUND);}
REMEMBER	{return(REMEMBER);}
REMEMBERING	{yylval.numval = REMEMBER; return(GERUND);}
ABSTAIN{W}FROM	{return(ABSTAIN);}
ABSTAINING	{yylval.numval = ABSTAIN; return(GERUND);}
REINSTATE	{return(REINSTATE);}
REINSTATING	{yylval.numval = REINSTATE; return(GERUND);}
\+		{return(INTERSECTION);}
GIVE{W}UP	{return(GIVE_UP);}
READ{W}OUT	{return(READ_OUT);}
WRITE{W}IN	{return(WRITE_IN);}
COME{W}FROM	{return(COME_FROM);}
COMING{W}FROM	{yylval.numval = COME_FROM; return(GERUND);}

[\ \t][\ \t]*	;
\n		{return(NEWLINE);}
.		{yylval.numval = yytext[0]; return(BADCHAR);}


%%

#ifdef MAIN
int yyerror()
{
    (void) printf("lextest: lexer error.\n");
}

main()
{
	int	t;

	while ((t = yylex()) > 0)
	{
		(void) printf("%03d %09d\n", t, yylval.numval);
		yylval.numval = 0;
	}
}
#endif /* MAIN */

static int yywrap()
{
    return(EOF);
}

